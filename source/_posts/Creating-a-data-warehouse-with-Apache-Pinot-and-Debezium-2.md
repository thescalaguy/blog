---
title: Creating a data warehouse with Apache Pinot and Debezium 2
tags:
  - architecture
date: 2024-12-19 10:31:25
---

In the [previous post](/2024/12/18/Creating-a-data-wrehouse-with-Apache-Pinot-and-Debezium/) we saw how we can stream data from Debezium into Pinot. In the field-level transformations that we applied, we stored the primary key along with the entire "after" JSON generated by Debezium. In this post we'll look at how to extract fields from the "after" payload so that the data looks more tabular.  

## Getting Started  

The JSON stored in the `source` column contains the user agent of the device used to to place the order. Let's say we'd like to find out the most common user agents. To do this, we'd need to extract the value from the JSON and store it in a new column. This will be a two-step process. First, we'll update the schema to add a new "user_agent" column. Second, we'll update the table definition to reflect this change in schema.  

Let's start by updating the schema. We'll add the following column to the `dimensionFieldSpecs`.  

{% code %}
{
    "name": "user_agent",
    "dataType": "STRING",
    "notNull": false
}
{% endcode %}  

Notice how we've set `notNull` to `false`. This allows the column to contain null values in case the user agent is unavailable. Let's PUT this updated schema to Pinot by executing the following curl command.  

{% code %}
curl -XPUT -F schemaName=@tables/002-orders/orders_schema.json localhost:9000/schemas/orders | jq .
{% endcode %}  

If we open the query console after updating the schema, we'll see the following error on the screen. It mentions that the segments are invalid because they were created from an older version of the schema and that to reflect the changes, we'd need to reload the table's segments. We'll get to this in a minute.

{% asset_img error.png %}  

Next, let's update the table by adding a new column. We'll add the following to the `transformConfigs`. Notice how we're referencing the `source` column in the `jsonPath` transform function.

{% code lang:json %}
{
    "columnName": "user_agent",
    "transformFunction": "jsonPath(source, '$.user_agent')"
}
{% endcode %}  

Let's PUT this updated config.  

{% code %}
curl -XPUT -H 'Content-Type: application/json' -d @tables/002-orders/orders_table.json localhost:9000/tables/orders | jq .
{% endcode %}

To ensure that the column is extracted even as more rows are generated by Debezium, we'll rerun the Python script which added dummy data.  

{% code lang:python %}
python faker/data.py
{% endcode %}  

We'll now reload the segments to let the changes take effect by executing the following command.  

{% code %}
curl -XPOST localhost:9000/segments/orders/reload | jq .
{% endcode %}

We can now reload the query console to see the changes take effect.

{% asset_img query.png %}  

Finally, a quick callout on schema evolution in Pinot. In Pinot schemas and tables, columns may only be added and not removed. This ensures backward compatibility.

That's it. That's how we can extract fields out of the `source` payload and into a column of their own.
